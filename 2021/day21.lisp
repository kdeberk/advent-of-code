(in-package :day21)

(setf *test-input* (list 4 8))
(setf *input* (list 6 8))

(defun part1 (input)
  (labels ((pos-score (pos)
             (if (= 0 pos) 10 pos)))
    (let ((dice 2) (n-throws 0)
          (pos-a (car input))
          (pos-b (cadr input))
          (score-a 0) (score-b 0))
      (loop
        (when (or (<= 1000 score-a) (<= 1000 score-b))
          (return (* (min score-a score-b)
                     n-throws)))
        (let ((throw (* 3 dice)))
          (if (= 0 (mod n-throws 2))
              (progn (setf pos-a (mod (+ pos-a throw) 10))
                     (incf score-a (pos-score pos-a)))
              (progn (setf pos-b (mod (+ pos-b throw) 10))
                     (incf score-b (pos-score pos-b)))))
        (incf dice 3)
        (incf n-throws 3)))))

(defvar *throws* (let ((throws (list 0)))
                   (dotimes (i 3)
                     (setf throws (apply #'append (mapcar (lambda (p) (list (+ p 1) (+ p 2) (+ p 3))) throws))))
                   throws))

(defun part2 (input)
  (let ((memo (make-hash-table :test #'equalp)))
    (labels ((throw-dice (pos score)
               (mapcar (lambda (throw)
                         (let ((pos (mod (+ pos throw) 10)))
                           (list pos (+ score (if (= 0 pos) 10 pos)))))
                       *throws*))
             (play (a-pos a-score b-pos b-score step)
               (let ((key (list a-pos a-score b-pos b-score step)))
                 (or (gethash key memo)
                     (let ((outcome (cond ((<= 21 a-score) (list 1 0))
                                          ((<= 21 b-score) (list 0 1))
                                          (t (reduce (lambda (acc cur)
                                                       (destructuring-bind (a-wins b-wins) cur
                                                         (incf (car acc) a-wins)
                                                         (incf (cadr acc) b-wins)
                                                         acc))
                                                     (if (= 0 (mod step 2))
                                                         (mapcar (lambda (nxt)
                                                                   (play (car nxt) (cadr nxt) b-pos b-score (1+ step)))
                                                                 (throw-dice a-pos a-score))
                                                         (mapcar (lambda (nxt)
                                                                   (play a-pos a-score (car nxt) (cadr nxt) (1+ step)))
                                                                 (throw-dice b-pos b-score)))
                                                     :initial-value (list 0 0))))))
                       (setf (gethash key memo) outcome)
                       outcome)))))
      (apply #'max (play (car input) 0 (cadr input) 0 0)))))
