(in-package :day24)

(defvar *test-input* (utils:read-input "day24_test.txt"))
(defvar *input* (utils:read-input "day24.txt"))

(defun read-input (input)
  (mapcar (lambda (line)
            (let ((line (string-trim '(#\Space) (car (str:split "//" line)))))
              (destructuring-bind (op arg1 &optional arg2) (str:split #\Space line)
                (list (intern op)
                      (or (ignore-errors (parse-integer arg1)) (intern arg1))
                      (or (ignore-errors (parse-integer arg2)) (when arg2 (intern arg2)))))))
          (str:split #\Newline (string-upcase input))))

(defun check-answer (instructions answer)
  (let ((state (mapcar (lambda (v) (cons v 0)) '(x y z w))))
    (dolist (instruction instructions)
      (destructuring-bind (op arg1 &optional arg2) instruction
        (cond ((eq 'inp op) (setf (cdr (assoc arg1 state)) (pop answer)))
              ((eq 'add op) (setf (cdr (assoc arg1 state)) (+ (if (numberp arg1) arg1 (cdr (assoc arg1 state)))
                                                              (if (numberp arg2) arg2 (cdr (assoc arg2 state))))))
              ((eq 'mul op) (setf (cdr (assoc arg1 state)) (* (if (numberp arg1) arg1 (cdr (assoc arg1 state)))
                                                              (if (numberp arg2) arg2 (cdr (assoc arg2 state))))))
              ((eq 'div op) (setf (cdr (assoc arg1 state)) (floor (/ (if (numberp arg1) arg1 (cdr (assoc arg1 state)))
                                                                     (if (numberp arg2) arg2 (cdr (assoc arg2 state)))))))

              ((eq 'mod op) (setf (cdr (assoc arg1 state)) (mod (if (numberp arg1) arg1 (cdr (assoc arg1 state)))
                                                                (if (numberp arg2) arg2 (cdr (assoc arg2 state))))))
              ((eq 'eq op) (setf (cdr (assoc arg1 state)) (if (= (if (numberp arg1) arg1 (cdr (assoc arg1 state)))
                                                                 (if (numberp arg2) arg2 (cdr (assoc arg2 state))))
                                                              1 0))))))
    state))

(defun analyze (instructions)
  (let ((state (mapcar (lambda (v) (cons v 0)) '(x y z w)))
        (input-counter 0)
        variables)
    (labels ((replace-with-var (expr)
               (cond ((numberp expr) expr)
                     ((symbolp expr) expr)
                     (expr (utils:if-let (found (find expr variables :test #'equalp :key #'cadr))
                                         (car found)
                                         (let ((name (intern (format nil "VAR-~d" (length variables)))))
                                           (push (list name expr) variables)
                                           name))))))
      (reduce (lambda (state instruction)
                (destructuring-bind (op arg1 &optional (arg2 0)) instruction
                  (setf (cdr (assoc arg1 state))
                        (let ((arg1 (cdr (assoc arg1 state)))
                              (arg2 (if (numberp arg2) arg2
                                        (replace-with-var (cdr (assoc arg2 state))))))
                          (let ((expr (cond ((eq 'mul op)
                                             (cond ((or (eq arg1 0) (eq arg2 0)) 0)
                                                   ((eq arg1 1) arg2)
                                                   ((eq arg2 1) arg1)
                                                   ((and (numberp arg1) (numberp arg2)) (* arg1 arg2))
                                                   (t (list '* arg1 arg2))))
                                            ((eq 'add op)
                                             (cond ((eq arg2 0) arg1)
                                                   ((eq arg1 0) arg2)
                                                   ((and (numberp arg1) (numberp arg2)) (+ arg1 arg2))
                                                   (t (list '+ arg1 arg2))))
                                            ((eq 'mod op)
                                             (if (eq arg1 0) 0 (list 'mod arg1 arg2)))
                                            ((eq 'div op)
                                             (cond ((eq arg1 0) 0)
                                                   ((eq arg2 1) arg1)
                                                   ((and (numberp arg1) (numberp arg2)) (floor (/ arg1 arg2)))
                                                   (t (list '/ arg1 arg2))))
                                            ((eq 'eql op)
                                             (cond ((and (numberp arg1) (numberp arg2)) (if (= arg1 arg2) 1 0))
                                                   (t (list '= arg1 arg2))))
                                            ((eq 'inp op)
                                             (intern (format nil "INPUT-~d" (incf input-counter)))))))
                            (replace-with-var expr)))))
                state)
              instructions
              :initial-value state))
    (list (reverse variables) (cdr (assoc 'z state)))))

(defun solve (variables)
  (labels ((solve-with (valuation)
             (let ((domains (make-hash-table :test 'eq)))
               (loop for x from 1 to 14 and val in valuation
                     do (setf (gethash (intern (format nil "INPUT-~d" x)) domains) val))
               (labels ((eval-expr (expr)
                          (cond ((symbolp expr) (gethash expr domains))
                                ((integerp expr) (list expr))
                                (t (destructuring-bind (op arg1 arg2) expr
                                     (remove-duplicates (loop for x in (eval-expr arg1)
                                                              append (loop for y in (eval-expr arg2)
                                                                           collect (cond ((eq op '=) (if (= x y) 1 0))
                                                                                         ((eq op '+) (+ x y))
                                                                                         ((eq op '*) (* x y))
                                                                                         ((eq op '/) (floor (/ x y)))
                                                                                         ((eq op 'mod) (mod x y)))))))))))
                 (loop for (name expr) in variables
                       do (setf (gethash name domains) (eval-expr expr)))

                 (find 0 (gethash (caar (last variables)) domains)))))
           (search-valuations (valuations idx)
             (cond ((not (solve-with valuations)) nil)
                   ((<= 14 idx) valuations)
                   (t (loop for i from 1 to 9
                            do (let ((found (search-valuations (append (subseq valuations 0 idx) (list (list i)) (subseq valuations (1+ idx))) (1+ idx))))
                                 (when found
                                   (return found))))))))

    (loop for x1 from 1 to 9
          do (loop for x2 from 1 to 9
                   do (utils:if-let (found (search-valuations `((,x1) (,x2) ,@(loop for i from 3 to 14 collect (loop for x from 1 to 9 collect x)))
                                                              2))
                                    (return-from solve found)
                                    (format t "~a ~a~%" x1 x2))))))


(defun part1 (input)
  (destructuring-bind (vars z) (analyze (read-input input))
    (loop for var in (reverse variables) and idx from 0
          do (format t "variable ~a: ~a~%" idx var))))
